## Онлайн обновление ленты новостей
```mermaid
---
title: Схема обновления ленты
---
flowchart LR
    subgraph Веб приложение
        B11[Веб сокет]
        B12[Веб сокет]
        C11[Локальная очередь]
        C12[Локальная очередь]
        D1[Хаб]
        G1[post/create]
        C11 --> B11
        C12 --> B12
        D1 --> C11
        D1 --> C12
    end
    subgraph RabbitMQ
        R1[Очередь]
        R2[Очередь]
    end
    subgraph Веб приложение
        B21[Веб сокет]
        B22[Веб сокет]
        C21[Локальная очередь]
        C22[Локальная очередь]
        D2[Хаб]
        G2[post/create]
        C21 --> B21
        C22 --> B22
        D2 --> C21
        D2 --> C22
    end
    A1[Клиент]
    A2[Клиент]
    A3[Клиент]
    A4[Клиент]
    A5[Клиент]
    A6[Клиент]
    B11 --> A1
    B12 --> A2
    B21 --> A3
    B22 --> A4
    D1 <--> R1
    D2 <--> R2
    A5 --> G1
    A6 --> G2
    G1 --> R1
    G1 --> R2
    G2 --> R1
    G2 --> R2
```
В качестве брокера сообщений выбран **RabbitMQ**.  
Каждый экземпляр веб-приложения читает из своей очереди, куда попадают сообщения механизмом **routing_key**.  
Веб-сокет доступен по адресу **/post/feed/posted**.

Запуск приложения
```sh
docker compose up
```

Генерация и вставка данных в postgresql
```sh
./db/generate_data.sh
```

Генерация и вставка данных в redis 
```sh
./cache/generate_data.sh
```

Остановка приложения
```sh
docker compose down
```

#### Масштабирование RabbitMQ
Есть возможность объединить несколько экземпляров RabbitMQ в один логический брокер через Erlang Cookie. 
Такой кластер имеет общие метаданные и очереди создаются только на одном узле. 
Клиент может подключаться к любому узлу и работать с очередями. 
Для распределения запросов необходимо использовать отдельный балансировщик.

#### Масштабирование сервиса веб-сокетов
Сервисом веб-сокетов является само веб-приложение, поэтому нужно запускать дополнительные экземпляры веб-приложения. 
Для кластера веб-серверов так же необходим балансировщик запросов.